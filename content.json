[{"title":"代码片段","date":"2017-06-23T05:49:42.000Z","path":"2017/06/23/代码片段/","text":"记录一些可能会用到的代码片段 RAF（requestAnimationFrame）//判断是否可以使用requestAnimFrame来替换setTimeout window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function(callback) { return window.setTimeout(callback, 1000 / 30); };","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"Mongoose学习笔记","date":"2017-06-14T06:27:15.000Z","path":"2017/06/14/Mongoose学习笔记/","text":"初学Node.js接触到MongoDB数据库，阅读资料中推荐的都是Mongoose模块，可以更加方便的对数据库进行操作。在学习时碰到许多基础问题，查阅了许多资料理来理解，此篇文章就是以自己的理解，记录下入门的基础知识，以及归纳下常用的函数以及格式，方便今后查阅。 引入与连接引入模块在需要使用的js文件中引入模块。 var mongoose = require(&apos;mongoose&apos;); 连接数据库 var db = mongoose.connect(&apos;mongodb://localhost/mongodb&apos;); URL以mongodb:// + [用户名:密码@] +数据库地址[:端口] + 数据库名。（默认端口27017）需要对连接状况进行判断，可以用以下代码： db.connection.on(&quot;error&quot;, function (error) { console.log(&quot;数据库连接失败：&quot; + error); }); db.connection.on(&quot;open&quot;, function () { console.log(&quot;数据库连接成功&quot;); }) db.connection.on(&apos;disconnected&apos;, function () { console.log(&apos;数据库连接断开&apos;); }) 基本概念最常接触到的有三个概念Schema、Model、Entity。按自己理解Schema是定义数据库的结构。类似创建表时的数据定义，但比创建数据库可以做更多的定义，只是没办法通过Schema对数据库进行更改。Model是将Schema定义的结构赋予表名。但可用此名对数据库进行增删查改。Entity是将Model与具体的数据绑定，可以对具体数据自身进行操作，例如保存数据。 SchemaSchema用来定义数据库文档结构，数据库有什么字段、字段是什么类型、默认值、主键之类的信息。除了定义结构外，还能定义文档的实例方法，静态模型方法，复合索引，中间件等。详情查看mongoose官方文档。在引入Mongoose模块var mongoose = require(‘mongoose’)的js文件中进行操作。 var blogSchema = new mongoose.Schema({ title: String, comments: [{ body: String, date: Date }], date: { type: Date, default: Date.now }, hidden: Boolean, meta: { votes: Number, favs: Number } }) 这样即定义了一个名为blogSchema的Schema。 如需再添加数据，用add方法。 blogSchema.add( { author: String, body: String} ); 资料中介绍，Shema不仅定义了文档的结构和属性，还可以定义文档的插件、实例方法、静态方法、复合索引文档生命周期钩子，具体还需查看官方文档。 Schema.Type Schema.Type是Mongoose内部定义的数据类型。基本类型有：String、Number、Date、Boolean、Array、Buffer、Mixed、ObjectId。 Mixed 混合数据类型，可以直接定义{}来使用，以下两种形式等价。 new Schema({mixed: {Schema.Types.Mixed} }); new Schema({mixed: {} }); ObjectId 储存在数据库中的每个数据都会有默认的主键_id，默认存储的是ObjectId。ObjectId是一个12字节的BSON类型字符串。按照字节顺序依次代表：4字节：UNIX时间戳3字节：表示运行MongoDB的机器2字节：表示生成此_id的进程3字节：由一个随机数开始的计数器生成的值 Modelvar blogModel = mongoose.model(&apos;Blog&apos;, blogSchema); 将名为blogSchema的Schema与Blog名字绑定，即是存入数据库的名字，但存入数据库中的名字是Blogs，会自动添加一个s。这里将Model命名为blogModel，需要对Blog表操作的话，都需要使用变量名blogModel。 Entity可以绑定具体数据对Model实例化。 var blogEntity = new blogModel({ title: &quot;Mongoose&quot;, author: &quot;L&quot;, body: &quot;Documents are instances of out model. Creating them and saving to the database is easy&quot;, comments: [{ body: &quot;It&apos;s very cool! Thanks a lot!&quot;, date: &quot;2014.07.28&quot; }], hidden: false, meta: { votes: 100, favs: 99 } }) 这里将名为blogModel的Model实例化。之后我们可以用blogEntity名对数据进行保存并执行回调。 blogEntity.save(function(err, docs){ if(err) console.log(err); console.log(&apos;保存成功：&apos; + docs); }) 在平常使用SQL语句操作数据库时，取得数据后先组织成SQL语句，然后放入执行语句中执行。这里理解也是类似，取得数据先进行实例化，这一步类似于组织成SQL语句，然后再做具体操作例如上面的Save操作。但由于Node.js是异步操作，所以返回的数据利用回调函数来进行操作。 知道了以上概念后就可以对数据进行操作了，下面将列出一些常用的资料，并附上相应的例子。 增查改删(CRUD)所有的参数都是以JSON对象形式传入。 增(C) Model.create(doc(s), [callback]) var doc = ({ title: &quot;Mongoose&quot;, author: &quot;L&quot;, body: &quot;Documents are instances of out model. Creating them and saving to the database is easy&quot;, comments: [{ body: &quot;It&apos;s very cool! Thanks a lot!&quot;, date: &quot;2014.07.28&quot; }], hidden: false, meta: { votes: 100, favs: 99 } }; blogModel.create(doc, function(err, docs){ if(err) console.log(err); console.log(&apos;保存成功：&apos; + docs); }); Model#save([options], [options.safe], [options.validateBeforeSave], [fn]) var blogEntity = new blogModel({ title: &quot;Mongoose&quot;, author: &quot;L&quot;, body: &quot;Documents are instances of out model. Creating them and saving to the database is easy&quot;, comments: [{ body: &quot;It&apos;s very cool! Thanks a lot!&quot;, date: &quot;2014.07.28&quot; }], hidden: false, meta: { votes: 100, favs: 99 } }); blogEntity.save(function(err, docs){ if(err) console.log(err); console.log(&apos;保存成功：&apos; + docs); }); Model.insertMany(doc(s), [options], [callback]) 多条数据插入，将多条数据一次性插入，相对于循环使用create保存会更加快。 blogModel.insertMany([ {title: &quot;mongoose1&quot;, author: &quot;L&quot;}, {title: &quot;mongoose2&quot;, author: &quot;L&quot;} ], function(err, docs){ if(err) console.log(err); console.log(&apos;保存成功：&apos; + docs); }); 查(R) Model.find(conditions, [projection], [options], [callback]) conditions：查询条件；projection：控制返回的字段；options：控制选项；callback：回调函数。 blogModel.find({title: &quot;Mongoose&quot;, meta.votes: 100}, {title: 1, author: 1, body: 1}, function(err, docs){ if(err) console.log(err); console.log(&apos;查询结果：&apos; + docs); }) 查询“title”标题为“Mongoose”，并且“meta”中“votes”字段值为“100”的记录，返回仅返回“title”、“author”、“body”三个字段的数据。 Model.findOne([conditions], [projection], [options], [callback]) conditions：查询条件；projection：控制返回的字段；options：控制选项；callback：回调函数。只返回第一个查询记录。 Model.findById(id, [projection], [options], [callback]) id：指定_id的值；projection：控制返回的字段；options：控制选项；callback：回调函数。 改(U) Model.update(conditions, doc, [options], [callback]) conditions：查询条件；doc：需要修改的数据，不能修改主键（_id）；options：控制选项；callback：回调函数，返回的是受影响的行数。options有以下选项： safe (boolean)： 默认为true。安全模式。 upsert (boolean)： 默认为false。如果不存在则创建新记录。 multi (boolean)： 默认为false。是否更新多个查询记录。 runValidators： 如果值为true，执行Validation验证。 setDefaultsOnInsert： 如果upsert选项为true，在新建时插入文档定义的默认值。 strict (boolean)： 以strict模式进行更新。 overwrite (boolean)： 默认为false。禁用update-only模式，允许覆盖记录。 blogModel.update({title: &quot;Mongoose&quot;}, {author: &quot;L&quot;}, {multi: true}, function(err, docs){ if(err) console.log(err); console.log(&apos;更改成功：&apos; + docs); }) 以上代码先查询“title”为“Mongoose”的数据，然后将它的“author”修改为“L”，“multi”为true允许更新多条查询记录。 Model.updateMany(conditions, doc, [options], [callback]) 一次更新多条 Model.updateOne(conditions, doc, [options], [callback]) 一次更新一条 Model.findByIdAndUpdate(id, [update], [options], [callback]) id：指定_id的值；update：需要修改的数据；options控制选项；callback回调函数。options有以下选项： new： bool - 默认为false。返回修改后的数据。 upsert： bool - 默认为false。如果不存在则创建记录。 runValidators： 如果值为true，执行Validation验证。 setDefaultsOnInsert： 如果upsert选项为true，在新建时插入文档定义的默认值。 sort： 如果有多个查询条件，按顺序进行查询更新。 select： 设置数据的返回。 Model.findOneAndUpdate([conditions], [update], [options], [callback]) conditions：查询条件；update：需要修改的数据；options控制选项；callback回调函数。options有以下选项： new： bool - 默认为false。返回修改后的数据。 upsert： bool - 默认为false。如果不存在则创建记录。 fields： {Object|String} - 选择字段。类似.select(fields).findOneAndUpdate()。 maxTimeMS： 查询用时上限。 sort： 如果有多个查询条件，按顺序进行查询更新。 runValidators： 如果值为true，执行Validation验证。 setDefaultsOnInsert： 如果upsert选项为true，在新建时插入文档定义的默认值。 passRawResult： 如果为真，将原始结果作为回调函数第三个参数。 删(D) Model.remove(conditions, [callback]) blogModel.remove({author: &quot;L&quot;}, function(err, docs){ if(err) console.log(err); console.log(&apos;删除成功：&apos; + docs); }) 删除“author”值为“L”的记录。 Model.findByIdAndRemove(id, [options], [callback]) id：指定_id的值；update：需要修改的数据；options控制选项；callback回调函数。options有以下选项： sort： 如果有多个查询条件，按顺序进行查询更新。 select： 设置数据的返回。 Model.findOneAndRemove(conditions, [options], [callback]) conditions：查询条件；update：需要修改的数据；options控制选项；callback回调函数。options有以下选项： sort： 如果有多个查询条件，按顺序进行查询更新。 maxTimeMS： 查询用时上限。 select： 设置数据的返回。 复杂条件查询在之前的查询说明中仅演示了确定值的查询，如果遇到更加复杂的情况就需要使用其他一些方法。详细的文档可以在这儿查找 mongodb查询符。 Query#exec([operation], [callback]) 执行查询，回调函数。使用find()、$where之类查询返回的是Mongoose自己封装的Query对象，使用find()可以在函数最后接上回调来获取查询到的数据。使用链式语句时，可以在之后接.exec()执行查询，并指定回调函数。 blogModel.find({title: &quot;Mongoose&quot;, meta.votes: 100}, {title: 1, author: 1, body: 1}).exec(function(err, docs){ if(err) console.log(err); console.log(&apos;查询结果：&apos; + docs); }) 配合各种查询符可以方便的实现复杂的查询。比如我需要查询“title”中以“Mongoose”开头，并且“meta”中“votes”的值小余100。并且按“meta”中“votes”的值升序排序。 blogModel.and([ { title: { $regex: &quot;Mongoose.+&quot;,&quot;$options&quot;:&quot;i&quot;}}, { meta.votes: { $lt: 100}} ).sort({ meta.votes: 1} ).exec(function(err, docs){ if(err) console.log(err); console.log(&apos;查询结果：&apos; + docs); }); 比较查询运算符 $equals 等于 ／ $gt 大于 ／ $gte 大于等于 ／ $lt 小余 ／ $lte 小余等于 ／ $ne 不等于 ／ $in 在数组中 ／ $nin 不在数组中 blogModel.find({meta.votes: {$lt: 100}}); 查询“meta”中的“votes”字段值小余100的数据。 blogModel.find({title: {$in: [&apos;Mongoose&apos;, &apos;Mongodb&apos;, &apos;Nodejs&apos;]}}); 查询“title”为“Mongoose”或“Mongodb”或“Nodejs”其中之一的数据。 逻辑查询运算符 $or 或 ／ $and 与 ／ $nor 非 blogModel.find({ $and: [ {meta.votes: {$gte: 50}}, {meta.votes: {$lt: 100}} ]}); 查询“meta”中的“votes”字段值大于等于50到小余100的数据。 blogModel.find({ $nor: [ {meta.votes: 50}, {meta.votes: 100} ]}); 查询“meta”中的“votes”字段值不等于50和不等于100的数据。 以上例子也可以写成这样形式，比较清晰，其他类同 blogModel.and([ {meta.votes: {$gte: 50}}, {meta.votes: {$lt: 100}} ]); blogModel.nor([ {meta.votes: 50}, {meta.votes: 100} ]); 元素查询运算符 $exists 查询的字段值是否存在 blogModel.find({ title: {$exists: true}}); blogModel.where(&apos;title&apos;).exists(true)； 查询存在“title”字段的数据。 评估查询运算符 $mod 与数据进行取模运算筛选 blogModel.find({ meta.votes: {$mod: [4, 0]}}); blogModel.where(&apos;meta.votes&apos;).$mod(4, 0); 查找“meta”中的“votes”字段值与4取模后，值为0的数据。 $regex 使用正则表达式查询数据 blogModel.find({ title: { $regex: &quot;Mongoose.+&quot;,&quot;$options&quot;:&quot;i&quot;}}); 搜索以“Mongoose”开头的“title”字段，“options”中的“i”代表不区分大小写。$options参数与其余用法可以查看mongodb文档中 $regex 一节。 $where 支持js表达式查询 blogModel.find({ $where: &apos;this.comments.length === 10 || this.name.length === 5&apos; }); blogModel.$where(function() { return this.comments.length === 10 || this.name.length === 5; }); 数组查询运算符 Query#all([path], val) 查询数组的本身及超集 blogModel.find( tags: [&apos;nodejs&apos;, &apos;mongoose&apos;]); 查询“tags”的字段值同时包含有[‘nodejs’, ‘mongoose’]的数据。只要值中包含此数组即返回数据，若是只包含数组中的一个则不返回此数据。 Query#elemMatch(path, criteria) 查询数组的交集 blogModel.find( $elemMatch: { tags: &apos;mongoose&apos;, author: &apos;L&apos;}); 查询“tags”为“mongoose”或是“author”为“L”的数据。 Query#size([path], val) 查询指定大小的数组 blogModel.find( tags: { $size: 2}); blogModel.where(&apos;tags&apos;).size(2); 查询“tags”数组中包含两个元素的数据。 其他常用的运算符 Query#limit(val) 限制查询返回的数量 blogModel.find( tags: &apos;mongoose&apos;).limit(5); 查询“tags”为“mongoose”的数据，只返回前5个查询结果。 Query#skip(val) 跳过前N个查询结果 blogModel.find( tags: &apos;mongoose&apos;).skip(10).limit(5); 查询“tags”为“mongoose”的数据，跳过前10个查询结果，返回从第11个开始的五个查询结果。做分页时常用到这两个，但数据量过大时就会有性能问题。 Query#sort(arg) 对结果按某个指定字段进行排序 1、asc为升序，-1、desc为降序。可以对一个字段进行排序，也可以是多个。 blogModel.find( tags: ‘mongoose’).skip(10).limit(5).sort(“{ meta.votes: 1}”); 查询“tags”为“mongoose”的数据，跳过前10个查询结果，返回从第11个开始的五个查询结果。之后按“votes”进行升序排序。 Query#count([criteria], [callback]) 计数 blogModel.count({ title: &apos;mongoose&apos;}, function(err, docs){}); 统计“title”为“mongoose”数据的数量 Query#select(arg) 选择指定字段 在查询中可以选择指定的查询字段，或者排除指定的字段。+为包含，-为排除。 blogModel.select(‘title body’); 只包含“title”、“body”字段。 blogModel.select(&apos;-title -body&apos;); 排除“title”、“body”字段。","tags":[]},{"title":"git远程服务器的搭建","date":"2017-06-13T01:40:24.000Z","path":"2017/06/13/git远程服务器的搭建/","text":"目标：本地使用git push后可以把本地代码提交到vps的git服务器和github上 在vps设置Git用户并安装Git登陆vps，切换到root用户： su - 添加一个叫git的用户来处理仓库： groupadd git adduser git -g git 然后为这个账户设置密码： passwd git 然后就是装git了：Centos/Fedora 执行命令： yum install git Ubuntu/Debian 执行命令： apt-get install git 将SSH密钥添加到访问列表（其实就是个ssh免密码登陆）下面是在vps上进行操作：切换到git账户： su git 将刚才产生的 id_rsa.pub 文件上传到git用户的home目录下（/home/git/）。然后告诉SSH守护进程去接受哪些ssh密钥： mkdir ~/.ssh &amp;&amp; touch ~/.ssh/authorized_keys 下面是windows上的操作： 如果你的vps ssh端口号不是22可以在本地.ssh文件夹下配置个config文件（没有新建） host bwg hostname xx.xx.xx.xx port xxxx 打开git bash，执行下面的命令，将产生的公钥内容拷贝到vps上的authorized_keys (注意替换命令中的用户名和ip) ： cat .ssh/id_rsa.pub | ssh git@bwg &quot;cat &gt;&gt; ~/.ssh/authorized_keys&quot; 然后看看能不能免密码登陆： ssh git@bwg 第一次登陆的时候会让你输入密码，以后再登陆就不需要输入密码了。 ===================================== 如果每次登陆都需要密码，则按照如下方法处理：1.进行ssh登录时，出现：”Agent admitted failure to sign using the key“ . 执行： $ssh-add 强行将私钥 加进来。2.如果无任何错误提示，可以输密码登录，但就是不能无密码登录，在被连接的主机上（如A向B发起ssh连接，则在B上）执行以下几步： $chmod o-w ~/&lt;br&gt; $chmod 700 ~/.ssh&lt;br&gt; $chmod 600 ~/.ssh/authorized_keys&lt;br&gt; 3.如果执行了第2步，还是不能无密码登录，再试试下面几个 $ps -Af | grep agent&lt;br&gt; 检查ssh代理是否开启，如果有开启的话，kill掉该代理，然后执行下面，重新打开一个ssh代理，如果没有开启，直接执行下面： $ssh-agent 还是不行的话，执行下面，重启一下ssh服务 $sudo service sshd restart 4.执行ssh-add时提示“Could not open a connection to your authenticationh agent”而失败执行： ssh-agent bash 在服务器上创建裸版本库：ps：远程仓库通常只是一个裸仓库（bare repository） — 即一个没有当前工作目录的仓库。因为该仓库只是一个合作媒介，所以不需要从硬盘上取出最新版本的快照；仓库里存放的仅仅是 Git 的数据。简单地说，裸仓库就是你工作目录中 .git 子目录内的内容 我们就在 /home/testgit/ 下创建一个叫 sample.git的裸仓库吧： mkdir /home/testgit cd /home/testgit git init --bare sample.git //这里 git init 是初始化空仓库的意思，而参数 –bare 是代表创建裸仓库，这个参数一定记得带上 当运行完上面的最后一句命令时，会有提示：Initialized empty Git repository in /home/testgit/sample.git/如果你得不到该结果，可能就要回头检查哪一步出问题了 创建web站点目录www 如果你已经拥有lamp环境，那么相信你已经了解该目录，搭建lamp环境详情可以看我的另一篇博客：centos 7搭建lamp平台环境、Centos7 系统下怎么更改apache默认网站目录 现在我的 web 站点目录在 /home/www 在本地克隆服务器上的裸仓库： 前提：本地已安装git打开 git bash ，我打算在我的D盘下clone 远程git服务器的版本库 cd /d git clone git@bwg:/home/testgit/sample.git 在这里如果没有配置公钥的话，会提示输入密码，但是我们可能并不知道密码，那就配置公钥咯： 如果使用git push失败了，极有可能是因为服务器的权限问题，就比如之前我们建的 testgit 文件夹，在这里我的解决方法是： chown -R git:git testgit 将testgit文件夹以及下面的子文件夹都赋给了git,这样就保证了推送成功。 第一次push可能会有一些提示，因为裸版本库还什么都没有，你可能需要 git push origin master写全命令，之后就没必要了，直接 git push 就可以了。 到目前为止，我们完成了第一个任务，实现了一个共享平台，既可拉取数据，又可以推送数据。 实现自动同步到站点目录（www）就比如刚才我们往远程仓库推送了index.html文件，虽然提示推送成功，但是我们现在在服务器端还看不到效果，心理总是不爽。又比如我写了个html页面，我想在站点中马上看到，那自动同步就派上用场了。 自动同步功能用到的是 git 的钩子功能， 服务器端：进入裸仓库：/home/testgit/sample.git cd /home/testgit/sample.git cd hooks 这里我们创建post-receive文件 vim post-receive 在该文件里输入以下内容 #!/bin/bash git --work-tree=/home/www checkout -f 保存退出后，将该文件用户及用户组都设置成git chown git:git post-receive 由于该文件其实就是一个shell文件，我们还应该为其设置可执行权限 chmod +x post-receive 现在我们可以在本地计算机中修改index.html文件，或者添加一个新文件，提交到远程仓库，然后到/home/www下面，看看有没有我们刚才提交的文件。 如果你在Git推送的工程中发现推送成功 但是在www目录下并没有自己的代码，这时候你可要注意了：这是由于文件夹的权限的原因造成的！ 假设你的www目录的所属的用户组为root，你可以将你的git用户加入这个组;并给git添加写入权限，或者其他解决方法，反正你要服务器上的git用户有权限进入www文件夹。 本地同时提交到vps的git服务器和github这里有个方便的方法：在本地仓库.git里config文件里加上你的github地址 [remote &quot;origin&quot;] url = git@bwg:/home/testgit/sample.git url = git@github.com:xxx/xxxx.git","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"ejs模板语法","date":"2017-06-10T00:16:16.000Z","path":"2017/06/10/ejs模板语法/","text":"1、EJS是一个简单高效的模板语言，通过数据和模板，可以生成HTML标记文本。可以说EJS是一个JavaScript库，EJS可以同时运行在客户端和服务器端，客户端安装直接引入文件即可，服务器端用npm包安装 2、EJS的特点： 快速编译和渲染 简单的模板标签 自定义标记分隔符 支持文本包含 支持浏览器端和服务器端 模板静态缓存 支持express视图系统 3、EJS成员函数： Render(str,data,[option]):直接渲染字符串并生成htmlstr：需要解析的字符串模板data：数据option：配置选项 Compile(str,[option]):编译字符串得到模板函数str：需要解析的字符串模板option：配置选项 两个函数包括的配置选项如下： 4、EJS常用标签 &lt;% %&gt;流程控制标签 &lt;%= %&gt;输出标签（原文输出HTML标签） &lt;%- %&gt;输出标签（HTML会被浏览器解析） &lt;%# %&gt;注释标签 % 对标记进行转义 -%&gt;去掉没用的空格 说明：ejs中的逻辑代码全部用JavaScript 5、接下来看一个例子就可以明白EJS的简单语法了 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;&lt;title&gt;EJS Examples&lt;/title&gt;&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt;&lt;link href=&quot;&quot; rel=&quot;stylesheet&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;ejs.min.js&quot;&gt;&lt;/script&gt;&lt;script &gt; var data=&#123;flag:false, data1:[&quot;====1&quot;,&quot;====2&quot;,&quot;====3&quot;], data2:[&quot;====4&quot;,&quot;====5&quot;,&quot;====6&quot;] &#125;; window.onload=function()&#123; var tem=document.getElementById(&quot;tem&quot;).innerHTML; var html=ejs.render(tem,data); document.getElementsByTagName(&quot;body&quot;)[0].innerHTML=html; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; id=&quot;tem&quot;&gt;&lt;ul&gt; &lt;%if(flag)&#123;%&gt; &lt;%for (var i=0;i&lt;data1.length;i++)&#123;%&gt; &lt;li&gt;&lt;%=data1[i]%&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;%&#125;else&#123;%&gt; &lt;%for(var i=0;i&lt;data2.length;i++)&#123;%&gt; &lt;li&gt;&lt;%=data2[i]%&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行后结果如下： ====4 ====5 ====6 4、过滤器（把结果进一步加工的函数）： 语法如下： &lt;%=: data.age | plus:5%&gt; 注意:和|两个符号:此外，还有文件包含的语法： &lt;%- include(path) %&gt; 参考文章地址","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"meta一些设置（未完）","date":"2017-06-07T02:26:26.000Z","path":"2017/06/07/meta的一些设置/","text":"META标签分两大部分：HTTP标题信息(HTTP-EQUIV)和页面描述信息(NAME)。 name 属性 123456789101112131415161718191、&lt;meta name=\"Generator\" contect=\"\"&gt;用以说明生成工具（如Microsoft FrontPage 4.0）等；2、&lt;meta name=\"KEYWords\" contect=\"\"&gt;向搜索引擎说明你的网页的关键词；3、&lt;meta name=\"DEscription\" contect=\"\"&gt;告诉搜索引擎你的站点的主要内容；4、&lt;meta name=\"Author\" contect=\"你的姓名\"&gt;告诉搜索引擎你的站点的制作的作者；5、&lt;meta name=\"Robots\" contect= \"all|none|index|noindex|follow|nofollow\"&gt;6、&lt;meta name=”renderer” content=”webkit|ie-comp|ie-stand” /&gt; 国产浏览器高速模式 其中的属性说明如下： 设定为all：文件将被检索，且页面上的链接可以被查询； 设定为none：文件将不被检索，且页面上的链接不可以被查询； 设定为index：文件将被检索； 设定为follow：页面上的链接可以被查询； 设定为noindex：文件将不被检索，但页面上的链接可以被查询； 设定为nofollow：文件将不被检索，页面上的链接可以被查询。 http-equiv属性123456789101112131415161718192021222324252627282930313233343536371、&lt;meta http-equiv=&quot;Content-Type&quot; contect=&quot;text/html&quot;;charset=gb_2312-80&quot;&gt;和 &lt;meta http-equiv=&quot;Content-Language&quot; contect=&quot;zh-CN&quot;&gt;用以说明主页制作所使用的文字以及语言；又如英文是ISO-8859-1字符集，还有BIG5、utf-8、shift-Jis、Euc、Koi8-2等字符集；2、&lt;meta http-equiv=&quot;Refresh&quot; contect=&quot;n;url=http://yourlink&quot;&gt;定时让网页在指定的时间n内，跳转到页面http://yourlink；3、&lt;meta http-equiv=&quot;Expires&quot; contect=&quot;Mon,12 May 2001 00:20:00 GMT&quot;&gt;可以用于设定网页的到期时间，一旦过期则必须到服务器上重新调用。需要注意的是必须使用GMT时间格式；4、&lt;meta http-equiv=&quot;Pragma&quot; contect=&quot;no-cache&quot;&gt;是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出；5、&lt;meta http-equiv=&quot;set-cookie&quot; contect=&quot;Mon,12 May 2001 00:20:00 GMT&quot;&gt;cookie设定，如果网页过期，存盘的cookie将被删除。需要注意的也是必须使用GMT时间格式；6、&lt;meta http-equiv=&quot;Pics-label&quot; contect=&quot;&quot;&gt;网页等级评定，在IE的internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过meta属性来设置的；7、&lt;meta http-equiv=&quot;windows-Target&quot; contect=&quot;_top&quot;&gt;强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用；8、&lt;meta http-equiv=&quot;Page-Enter&quot; contect=&quot;revealTrans(duration=10,transtion= 50)&quot;&gt;和&lt;meta http-equiv=&quot;Page-Exit&quot; contect=&quot;revealTrans(duration=20，transtion=6)&quot;&gt;设定进入和离开页面时的特殊效果，这个功能即FrontPage中的“格式/网页过渡”，不过所加的页面不能够是一个frame页面。Open Graph ProtocolMeta Property=og标签是什么呢?og是一种新的HTTP头部标记，即Open Graph Protocol：The Open Graph Protocol enables any web page to become a rich object in a social graph.+ n3 &#125;即这种协议可以让网页成为一个“富媒体对象”。用了Meta Property=og标签，就是你同意了网页内容可以被其他社会化网站引用等，目前这种协议被SNS网站如Fackbook、renren采用。SNS已经成为网络上的一大热门应用，优质的内容通过分享在好友间迅速传播。为了提高站外内容的传播效率，2010年F8会议上Facebook公布 了一套开放内容协议(Open Graph Protocol)，任何网页只要遵守该协议，SNS就能从页面上提取最有效的信息并呈现给用户。 &lt;meta property=”og:type” content=”video”/&gt; &lt;meta property=”og:title” content=”五月天_突然好想你MV现场版”/&gt; &lt;meta property=”og:image” content=”http://g1.ykimg.com/0100641F464A ... 9-76EA-E5E20A1887C4″/&gt; &lt;meta property=”og:url” content=”http://v.youku.com/v_show/id_XMTIyMTY5NzMy.html”/&gt; &lt;meta property=”og:videosrc” content=”http://player.youku.com/player.p ... AutoPlay=true/v.swf”/&gt; &lt;meta property=”og:width” content=”500″ /&gt; &lt;meta property=”og:height” content=”416″ /&gt; &lt;meta property=”og:type” content=”video”/&gt; &lt;meta property=”og:title” content=”五月天_突然好想你MV现场版_AA”/&gt; &lt;meta property=”og:image” content=”http://g1.ykimg.com/0100641F464A ... EA-E5E20A1887C44444″/&gt; &lt;meta property=”og:url” content=”http://v.youku.com/v_show/id_XMTIyMTY5NzMyyyyyyyyyyyyyyyy.html”/&gt; &lt;meta property=”og:videosrc” content=”http://player.youku.com/player.p ... AutoPlay=true/y.swf”/&gt; &lt;meta property=”og:width” content=”600″ /&gt; &lt;meta property=”og:height” content=”716″/&gt; &lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-CN&quot; /&gt; html代码语言采用中文 &lt;meta property=&quot;qc:admins&quot; content=&quot;153033120760567656375&quot; /&gt; QQ登陆声明 &lt;meta property=&quot;wb:webmaster&quot; content=&quot;e9da5e10879ed7c9&quot; /&gt; 微博登陆声明 &lt;meta name=&quot;google-site-verification&quot; content=&quot;tPkY-Quj85Ni78uIWOIREPO9k5xczDgjch10qsLfVfs&quot; /&gt; google的网站认证代码，证明该网站的所有者是你","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"防止页面被iframe嵌套","date":"2017-06-06T02:40:42.000Z","path":"2017/06/06/防止网页被iframe嵌套/","text":"自己的网页被别人盗用很不爽吧，以下是几种解方案 方案一if (top != self) { top.location = self.location; } 方案二if (self == top) { var theBody = document.getElementsByTagName(&apos;body&apos;)[0]; theBody.style.display = &quot;block&quot;; } else { top.location = self.location; } 方案三在响应头里加一个X-Frame-Options 取值有三种，大部分浏览器都支持： 1. DENY：浏览器拒绝当前页面加载任何Frame页面 2. SAMEORIGIN：frame页面的地址只能为同源域名下的页面 3. ALLOW-FROM origin：origin为允许frame加载的页面地址","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"省略号动画","date":"2017-06-05T02:40:42.000Z","path":"2017/06/05/省略号动画/","text":"一些漂亮的等待动画：点这里 三个点的简单等待的动画效果： .dotting{ display: inline-block; width: 20px; min-height: 4px; padding-right: 4px; border-left: 4px solid currentColor; border-right: 4px solid currentColor; background-color: currentColor; background-clip: content-box; box-sizing: border-box; -webkit-animation: dot 4s infinite step-start both; animation: dot 4s infinite step-start both; &amp;:before{ content: &apos;...&apos;; /* IE8 */ } &amp;::before{ content: &apos;&apos;; } } :root .dotting { margin-left: 4px; padding-left: 4px; } /* IE9+ */ @-webkit-keyframes dot { 25% { border-color: transparent; background-color: transparent; } 50% { border-right-color: transparent; background-color: transparent; } 75% { border-right-color: transparent; } } @keyframes dot { 25% { border-color: transparent; background-color: transparent; } 50% { border-right-color: transparent; background-color: transparent; } 75% { border-right-color: transparent; } }","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"placeholder支持","date":"2017-06-01T00:16:16.000Z","path":"2017/06/01/placeholder的支持/","text":"IE9及以上不支持placeholder属性，可以通过一下方法模拟： if(&apos;placeholder&apos; in document.createElement(&apos;input&apos;)){ }else{ $(&apos;[placeholder]&apos;).focus(function() { var input = $(this); if (input.val() == input.attr(&apos;placeholder&apos;)) { input.val(&apos;&apos;); input.removeClass(&apos;placeholder&apos;); } }).blur(function() { var input = $(this); if (input.val() == &apos;&apos; || input.val() == input.attr(&apos;placeholder&apos;)) { input.addClass(&apos;placeholder&apos;); input.val(input.attr(&apos;placeholder&apos;)); } }).blur(); }","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"移动端touch事件整理","date":"2017-05-28T06:44:44.000Z","path":"2017/05/28/移动端touch事件/","text":"移动端触摸事件 touchstart事件：触摸时触发（坐标信息可以从touches里获得） touchmove事件：滑动时触发（同上） touched事件：手指离开时触发（需要从changeTouches中获取离开时坐标） touchcancel事件：当系统停止跟踪触摸的时候触发 上面的这些事件都会冒泡，也都可以取消。虽然这些触摸事件没有在DOM规范中定义，但是它们却是以兼容DOM的方式实现的。所以，每个触摸事件的event对象都提供了在鼠标实践中常见的属性：bubbles(起泡事件的类型)、cancelable(是否用 preventDefault() 方法可以取消与事件关联的默认动作)、clientX(返回当事件被触发时，鼠标指针的水平坐标)、clientY(返回当事件触发时，鼠标指针的垂直坐标)、screenX(当某个事件被触发时，鼠标指针的水平坐标)和screenY(返回当某个事件被触发时，鼠标指针的垂直坐标)。除了常见的DOM属性，触摸事件还包含下面三个用于跟踪触摸的属性。 touches：表示当前跟踪的触摸操作的touch对象的数组。 targetTouches：特定于事件目标的Touch对象的数组。 changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。 每个Touch对象包含的属性如下。 clientX：触摸目标在视口中的x坐标。 clientY：触摸目标在视口中的y坐标。 identifier：标识触摸的唯一ID。 pageX：触摸目标在页面中的x坐标。 pageY：触摸目标在页面中的y坐标。 screenX：触摸目标在屏幕中的x坐标。 screenY：触摸目标在屏幕中的y坐标。 target：触目的DOM节点目标。","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"图片预览上传","date":"2017-05-27T08:36:36.000Z","path":"2017/05/27/图片预览上传/","text":"图片的上传和预览 HTML的布局&lt;div class=&apos;uploadImgBox&apos;&gt; &lt;ul class=&apos;imgList&apos; id=&quot;imgListModify&quot;&gt; &lt;li style=&apos;background-image:url(img/2.jpg)&apos;&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/li&gt; &lt;li style=&apos;background-image:url(img/1.jpg)&apos;&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;a class=&apos;button button-big&apos; onclick=&quot;loadImg(this)&quot;&gt;上传图片&lt;/a&gt; &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; multiple id=&quot;abc&quot;&gt; &lt;/div&gt; SCSS样式.uploadImgBox{ padding: 0 .75rem; .imgList { display: flex; padding-left: 0; margin-bottom: .5rem; flex-flow: row wrap; li{ text-align: center; width: 100px; height: 100px; background-repeat: no-repeat; background-position: center center; background-size: cover; margin: .5rem .5rem .5rem 0; position: relative; span{ width: 20px; height: 20px; line-height: 20px; font-size: 1.2em; background: #000; border-radius: 50%; color:#fff; position: absolute; right: 0; top: 0; margin: -10px -10px 0 0; } } } input { display: none; } } js代码function loadImg(that) { if (typeof FileReader === &apos;undefined&apos;) { $.toast(&apos;您的手机不支持上传图片&apos;, 2000,&apos;toast-11&apos;); return } var inp = $(that).next(&apos;input&apos;)[0] inp.click() inp.onchange=function() { var imgFile = inp.files if (imgFile.length == 0) return if (imgFile.length &gt; 9){ $.toast(&apos;最多上传9张图片&apos;) } $(imgFile).each(function (i, v) { if (!/\\/(?:jpeg|png|gif)/i.test(v.type)) return; var reader = new FileReader() reader.readAsDataURL(v); reader.onload = function () { var url = this.result $(that).prev(&apos;ul&apos;).append(&quot;&lt;li style=&apos;background-image:url(&quot;+url+&quot;)&apos;&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/li&gt;&quot;) } }) } } 参考代码 （压缩 预览 上传）原网址找不到了：js部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228function uploadImg() &#123; var filechooser = document.getElementById(\"chooseImg\"); // 用于压缩图片的canvas var canvas = document.createElement(\"canvas\"); var ctx = canvas.getContext('2d'); // 瓦片canvas var tCanvas = document.createElement(\"canvas\"); var tctx = tCanvas.getContext(\"2d\"); var maxsize = 100 * 1024; $(\"#upload\").on(\"click\", function () &#123; filechooser.click(); &#125;) filechooser.onchange = function () &#123; if (!this.files.length) return; var files = Array.prototype.slice.call(this.files); if (files.length &gt; 9) &#123; alert(\"最多同时只可上传9张图片\"); return; &#125; files.forEach(function (file, i) &#123; if (!/\\/(?:jpeg|png|gif)/i.test(file.type)) return; var reader = new FileReader(); var li = document.createElement(\"li\"); // 获取图片大小 var size = file.size / 1024 &gt; 1024 ? (~~(10 * file.size / 1024 / 1024)) / 10 + \"MB\" : ~~(file.size / 1024) + \"KB\"; li.innerHTML = '&lt;div class=\"progress\"&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=\"size\"&gt;' + size + '&lt;/div&gt;'; $(\".img-list\").append($(li)); reader.onload = function () &#123; var result = this.result; var img = new Image(); img.src = result; $(li).css(\"background-image\", \"url(\" + result + \")\"); //如果图片大小小于100kb，则直接上传 if (result.length &lt;= maxsize) &#123; img = null; upload(result, file.type, $(li)); return; &#125; // 图片加载完毕之后进行压缩，然后上传 if (img.complete) &#123; callback(); &#125; else &#123; img.onload = callback; &#125; function callback() &#123; var data = compress(img); upload(data, file.type, $(li)); img = null; &#125; &#125;; reader.readAsDataURL(file); &#125;) &#125;; // 使用canvas对大图片进行压缩 function compress(img) &#123; var initSize = img.src.length; var width = img.width; var height = img.height; //如果图片大于四百万像素，计算压缩比并将大小压至400万以下 var ratio; if ((ratio = width * height / 4000000) &gt; 1) &#123; ratio = Math.sqrt(ratio); width /= ratio; height /= ratio; &#125; else &#123; ratio = 1; &#125; canvas.width = width; canvas.height = height; // 铺底色 ctx.fillStyle = \"#fff\"; ctx.fillRect(0, 0, canvas.width, canvas.height); //如果图片像素大于100万则使用瓦片绘制 var count; if ((count = width * height / 1000000) &gt; 1) &#123; count = ~~(Math.sqrt(count) + 1); //计算要分成多少块瓦片 // 计算每块瓦片的宽和高 var nw = ~~(width / count); var nh = ~~(height / count); tCanvas.width = nw; tCanvas.height = nh; for (var i = 0; i &lt; count; i++) &#123; for (var j = 0; j &lt; count; j++) &#123; tctx.drawImage(img, i * nw * ratio, j * nh * ratio, nw * ratio, nh * ratio, 0, 0, nw, nh); ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh); &#125; &#125; &#125; else &#123; ctx.drawImage(img, 0, 0, width, height); &#125; //进行最小压缩 var ndata = canvas.toDataURL('image/jpeg', 0.1); console.log('压缩前：' + initSize); console.log('压缩后：' + ndata.length); console.log('压缩率：' + ~~(100 * (initSize - ndata.length) / initSize) + \"%\"); tCanvas.width = tCanvas.height = canvas.width = canvas.height = 0; return ndata; &#125; // 图片上传，将base64的图片转成二进制对象，塞进formdata上传 function upload(basestr, type, $li) &#123; var text = window.atob(basestr.split(\",\")[1]); var buffer = new Uint8Array(text.length); var pecent = 0, loop = null; for (var i = 0; i &lt; text.length; i++) &#123; buffer[i] = text.charCodeAt(i); &#125; var blob = getBlob([buffer], type); var xhr = new XMLHttpRequest(); var formdata = getFormData(); formdata.append('imagefile', blob); xhr.open('post', '/cupload'); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; var jsonData = JSON.parse(xhr.responseText); var imagedata = jsonData[0] || &#123;&#125;; var text = imagedata.path ? '上传成功' : '上传失败'; console.log(text + '：' + imagedata.path); clearInterval(loop); //当收到该消息时上传完毕 $li.find(\".progress span\").animate(&#123; 'width': \"100%\" &#125;, pecent &lt; 95 ? 200 : 0, function () &#123; $(this).html(text); &#125;); if (!imagedata.path) return; $(\".pic-list\").append('&lt;a href=\"' + imagedata.path + '\"&gt;' + imagedata.name + '（' + imagedata.size + '）&lt;img src=\"' + imagedata.path + '\" /&gt;&lt;/a&gt;'); &#125; &#125;; //数据发送进度，前50%展示该进度 xhr.upload.addEventListener('progress', function (e) &#123; if (loop) return; pecent = ~~(100 * e.loaded / e.total) / 2; $li.find(\".progress span\").css('width', pecent + \"%\"); if (pecent == 50) &#123; mockProgress(); &#125; &#125;, false); //数据后50%用模拟进度 function mockProgress() &#123; if (loop) return; loop = setInterval(function () &#123; pecent++; $li.find(\".progress span\").css('width', pecent + \"%\"); if (pecent == 99) &#123; clearInterval(loop); &#125; &#125;, 100) &#125; xhr.send(formdata); &#125; /** * 获取blob对象的兼容性写法 * @param buffer * @param format * @returns &#123;*&#125; */ function getBlob(buffer, format) &#123; try &#123; return new Blob(buffer, &#123; type: format &#125;); &#125; catch (e) &#123; var bb = new(window.BlobBuilder || window.WebKitBlobBuilder || window.MSBlobBuilder); buffer.forEach(function (buf) &#123; bb.append(buf); &#125;); return bb.getBlob(format); &#125; &#125; /** * 获取formdata */ function getFormData() &#123; var isNeedShim = ~navigator.userAgent.indexOf('Android') &amp;&amp; ~navigator.vendor.indexOf('Google') &amp;&amp; !~navigator.userAgent.indexOf('Chrome') &amp;&amp; navigator.userAgent.match(/AppleWebKit\\/(\\d+)/).pop() &lt;= 534; return isNeedShim ? new FormDataShim() : new FormData() &#125; /** * formdata 补丁, 给不支持formdata上传blob的android机打补丁 * @constructor */ function FormDataShim() &#123; console.warn('using formdata shim'); var o = this, parts = [], boundary = Array(21).join('-') + (+new Date() * (1e16 * Math.random())).toString(36), oldSend = XMLHttpRequest.prototype.send; this.append = function (name, value, filename) &#123; parts.push('--' + boundary + '\\r\\nContent-Disposition: form-data; name=\"' + name + '\"'); if (value instanceof Blob) &#123; parts.push('; filename=\"' + (filename || 'blob') + '\"\\r\\nContent-Type: ' + value.type + '\\r\\n\\r\\n'); parts.push(value); &#125; else &#123; parts.push('\\r\\n\\r\\n' + value); &#125; parts.push('\\r\\n'); &#125;; // Override XHR send() XMLHttpRequest.prototype.send = function (val) &#123; var fr, data, oXHR = this; if (val === o) &#123; // Append the final boundary string parts.push('--' + boundary + '--\\r\\n'); // Create the blob data = getBlob(parts); // Set up and read the blob into an array to be sent fr = new FileReader(); fr.onload = function () &#123; oldSend.call(oXHR, fr.result); &#125;; fr.onerror = function (err) &#123; throw err; &#125;; fr.readAsArrayBuffer(data); // Set the multipart content type and boudary this.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + boundary); XMLHttpRequest.prototype.send = oldSend; &#125; else &#123; oldSend.call(this, val); &#125; &#125;; &#125;&#125;","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"markdown语法教程","date":"2017-05-25T09:43:03.000Z","path":"2017/05/25/markdown语法教程/","text":"完整版Markdown 语法手册（完整版） 目录[TOC] 目录如上[TOC]所示 斜体和粗体我是斜体 或 斜体 *斜体* _斜体_ 我是粗体 **粗体** 删除线 ~~删除线~~ 链接点我 ​ [点我]（https://saihy2016.github.io/） ![图片]（C:\\Users\\Administrator\\Desktop\\my\\blogMD\\hua.jpg “美丽花儿”） 锚点 我要调到 列表引用插入图像内容目录注脚LaTeX公式流程图表格","tags":[]},{"title":"hexo博客搭好啦","date":"2017-05-20T01:40:24.000Z","path":"2017/05/20/hexo博客搭好啦/","text":"折腾了一上午，终于搭好了自己的博客啦，好开心，好兴奋，今天520，我要去陪女票啦，美好的一天，嗯木啊","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Hello World","date":"2017-05-18T02:26:26.000Z","path":"2017/05/18/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]