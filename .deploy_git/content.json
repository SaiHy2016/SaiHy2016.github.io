[{"title":"git远程服务器的搭建","date":"2017-06-13T01:40:24.000Z","path":"2017/06/13/git远程服务器的搭建/","text":"目标：本地使用git push后可以把本地代码提交到vps的git服务器和github上 在vps设置Git用户并安装Git登陆vps，切换到root用户： su - 添加一个叫git的用户来处理仓库： groupadd git adduser git -g git 然后为这个账户设置密码： passwd git 然后就是装git了：Centos/Fedora 执行命令： yum install git Ubuntu/Debian 执行命令： apt-get install git 将SSH密钥添加到访问列表（其实就是个ssh免密码登陆）下面是在vps上进行操作：切换到git账户： su git 将刚才产生的 id_rsa.pub 文件上传到git用户的home目录下（/home/git/）。然后告诉SSH守护进程去接受哪些ssh密钥： mkdir ~/.ssh &amp;&amp; touch ~/.ssh/authorized_keys 下面是windows上的操作： 如果你的vps ssh端口号不是22可以在本地.ssh文件夹下配置个config文件（没有新建） host bwg hostname xx.xx.xx.xx port xxxx 打开git bash，执行下面的命令，将产生的公钥内容拷贝到vps上的authorized_keys (注意替换命令中的用户名和ip) ： cat .ssh/id_rsa.pub | ssh git@bwg &quot;cat &gt;&gt; ~/.ssh/authorized_keys&quot; 然后看看能不能免密码登陆： ssh git@bwg 第一次登陆的时候会让你输入密码，以后再登陆就不需要输入密码了。 ===================================== 如果每次登陆都需要密码，则按照如下方法处理：1.进行ssh登录时，出现：”Agent admitted failure to sign using the key“ . 执行： $ssh-add 强行将私钥 加进来。2.如果无任何错误提示，可以输密码登录，但就是不能无密码登录，在被连接的主机上（如A向B发起ssh连接，则在B上）执行以下几步： $chmod o-w ~/&lt;br&gt; $chmod 700 ~/.ssh&lt;br&gt; $chmod 600 ~/.ssh/authorized_keys&lt;br&gt; 3.如果执行了第2步，还是不能无密码登录，再试试下面几个 $ps -Af | grep agent&lt;br&gt; 检查ssh代理是否开启，如果有开启的话，kill掉该代理，然后执行下面，重新打开一个ssh代理，如果没有开启，直接执行下面： $ssh-agent 还是不行的话，执行下面，重启一下ssh服务 $sudo service sshd restart 4.执行ssh-add时提示“Could not open a connection to your authenticationh agent”而失败执行： ssh-agent bash 在服务器上创建裸版本库：ps：远程仓库通常只是一个裸仓库（bare repository） — 即一个没有当前工作目录的仓库。因为该仓库只是一个合作媒介，所以不需要从硬盘上取出最新版本的快照；仓库里存放的仅仅是 Git 的数据。简单地说，裸仓库就是你工作目录中 .git 子目录内的内容 我们就在 /home/testgit/ 下创建一个叫 sample.git的裸仓库吧： mkdir /home/testgit cd /home/testgit git init --bare sample.git //这里 git init 是初始化空仓库的意思，而参数 –bare 是代表创建裸仓库，这个参数一定记得带上 当运行完上面的最后一句命令时，会有提示：Initialized empty Git repository in /home/testgit/sample.git/如果你得不到该结果，可能就要回头检查哪一步出问题了 创建web站点目录www 如果你已经拥有lamp环境，那么相信你已经了解该目录，搭建lamp环境详情可以看我的另一篇博客：centos 7搭建lamp平台环境、Centos7 系统下怎么更改apache默认网站目录 现在我的 web 站点目录在 /home/www 在本地克隆服务器上的裸仓库： 前提：本地已安装git打开 git bash ，我打算在我的D盘下clone 远程git服务器的版本库 cd /d git clone git@bwg:/home/testgit/sample.git 在这里如果没有配置公钥的话，会提示输入密码，但是我们可能并不知道密码，那就配置公钥咯： 如果使用git push失败了，极有可能是因为服务器的权限问题，就比如之前我们建的 testgit 文件夹，在这里我的解决方法是： chown -R git:git testgit 将testgit文件夹以及下面的子文件夹都赋给了git,这样就保证了推送成功。 第一次push可能会有一些提示，因为裸版本库还什么都没有，你可能需要 git push origin master写全命令，之后就没必要了，直接 git push 就可以了。 到目前为止，我们完成了第一个任务，实现了一个共享平台，既可拉取数据，又可以推送数据。 实现自动同步到站点目录（www）就比如刚才我们往远程仓库推送了index.html文件，虽然提示推送成功，但是我们现在在服务器端还看不到效果，心理总是不爽。又比如我写了个html页面，我想在站点中马上看到，那自动同步就派上用场了。 自动同步功能用到的是 git 的钩子功能， 服务器端：进入裸仓库：/home/testgit/sample.git cd /home/testgit/sample.git cd hooks 这里我们创建post-receive文件 vim post-receive 在该文件里输入以下内容 #!/bin/bash git --work-tree=/home/www checkout -f 保存退出后，将该文件用户及用户组都设置成git chown git:git post-receive 由于该文件其实就是一个shell文件，我们还应该为其设置可执行权限 chmod +x post-receive 现在我们可以在本地计算机中修改index.html文件，或者添加一个新文件，提交到远程仓库，然后到/home/www下面，看看有没有我们刚才提交的文件。 如果你在Git推送的工程中发现推送成功 但是在www目录下并没有自己的代码，这时候你可要注意了：这是由于文件夹的权限的原因造成的！ 假设你的www目录的所属的用户组为root，你可以将你的git用户加入这个组;并给git添加写入权限，或者其他解决方法，反正你要服务器上的git用户有权限进入www文件夹。 本地同时提交到vps的git服务器和github这里有个方便的方法：在本地仓库.git里config文件里加上你的github地址 [remote &quot;origin&quot;] url = git@bwg:/home/testgit/sample.git url = git@github.com:xxx/xxxx.git","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"ejs模板语法","date":"2017-06-10T00:16:16.000Z","path":"2017/06/10/ejs模板语法/","text":"1、EJS是一个简单高效的模板语言，通过数据和模板，可以生成HTML标记文本。可以说EJS是一个JavaScript库，EJS可以同时运行在客户端和服务器端，客户端安装直接引入文件即可，服务器端用npm包安装 2、EJS的特点： 快速编译和渲染 简单的模板标签 自定义标记分隔符 支持文本包含 支持浏览器端和服务器端 模板静态缓存 支持express视图系统 3、EJS成员函数： Render(str,data,[option]):直接渲染字符串并生成htmlstr：需要解析的字符串模板data：数据option：配置选项 Compile(str,[option]):编译字符串得到模板函数str：需要解析的字符串模板option：配置选项 两个函数包括的配置选项如下： 4、EJS常用标签 &lt;% %&gt;流程控制标签 &lt;%= %&gt;输出标签（原文输出HTML标签） &lt;%- %&gt;输出标签（HTML会被浏览器解析） &lt;%# %&gt;注释标签 % 对标记进行转义 -%&gt;去掉没用的空格 说明：ejs中的逻辑代码全部用JavaScript 5、接下来看一个例子就可以明白EJS的简单语法了 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;&lt;title&gt;EJS Examples&lt;/title&gt;&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;&lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt;&lt;link href=&quot;&quot; rel=&quot;stylesheet&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;ejs.min.js&quot;&gt;&lt;/script&gt;&lt;script &gt; var data=&#123;flag:false, data1:[&quot;====1&quot;,&quot;====2&quot;,&quot;====3&quot;], data2:[&quot;====4&quot;,&quot;====5&quot;,&quot;====6&quot;] &#125;; window.onload=function()&#123; var tem=document.getElementById(&quot;tem&quot;).innerHTML; var html=ejs.render(tem,data); document.getElementsByTagName(&quot;body&quot;)[0].innerHTML=html; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; id=&quot;tem&quot;&gt;&lt;ul&gt; &lt;%if(flag)&#123;%&gt; &lt;%for (var i=0;i&lt;data1.length;i++)&#123;%&gt; &lt;li&gt;&lt;%=data1[i]%&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;%&#125;else&#123;%&gt; &lt;%for(var i=0;i&lt;data2.length;i++)&#123;%&gt; &lt;li&gt;&lt;%=data2[i]%&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行后结果如下： ====4 ====5 ====6 4、过滤器（把结果进一步加工的函数）： 语法如下： &lt;%=: data.age | plus:5%&gt; 注意:和|两个符号:此外，还有文件包含的语法： &lt;%- include(path) %&gt; 参考文章地址","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"meta一些设置（未完）","date":"2017-06-07T02:26:26.000Z","path":"2017/06/07/meta的一些设置/","text":"META标签分两大部分：HTTP标题信息(HTTP-EQUIV)和页面描述信息(NAME)。 name 属性 12345678910111213141516171、&lt;meta name=\"Generator\" contect=\"\"&gt;用以说明生成工具（如Microsoft FrontPage 4.0）等；2、&lt;meta name=\"KEYWords\" contect=\"\"&gt;向搜索引擎说明你的网页的关键词；3、&lt;meta name=\"DEscription\" contect=\"\"&gt;告诉搜索引擎你的站点的主要内容；4、&lt;meta name=\"Author\" contect=\"你的姓名\"&gt;告诉搜索引擎你的站点的制作的作者；5、&lt;meta name=\"Robots\" contect= \"all|none|index|noindex|follow|nofollow\"&gt; 其中的属性说明如下： 设定为all：文件将被检索，且页面上的链接可以被查询； 设定为none：文件将不被检索，且页面上的链接不可以被查询； 设定为index：文件将被检索； 设定为follow：页面上的链接可以被查询； 设定为noindex：文件将不被检索，但页面上的链接可以被查询； 设定为nofollow：文件将不被检索，页面上的链接可以被查询。 http-equiv属性123456789101112131415161718192021222324252627282930313233343536371、&lt;meta http-equiv=&quot;Content-Type&quot; contect=&quot;text/html&quot;;charset=gb_2312-80&quot;&gt;和 &lt;meta http-equiv=&quot;Content-Language&quot; contect=&quot;zh-CN&quot;&gt;用以说明主页制作所使用的文字以及语言；又如英文是ISO-8859-1字符集，还有BIG5、utf-8、shift-Jis、Euc、Koi8-2等字符集；2、&lt;meta http-equiv=&quot;Refresh&quot; contect=&quot;n;url=http://yourlink&quot;&gt;定时让网页在指定的时间n内，跳转到页面http://yourlink；3、&lt;meta http-equiv=&quot;Expires&quot; contect=&quot;Mon,12 May 2001 00:20:00 GMT&quot;&gt;可以用于设定网页的到期时间，一旦过期则必须到服务器上重新调用。需要注意的是必须使用GMT时间格式；4、&lt;meta http-equiv=&quot;Pragma&quot; contect=&quot;no-cache&quot;&gt;是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出；5、&lt;meta http-equiv=&quot;set-cookie&quot; contect=&quot;Mon,12 May 2001 00:20:00 GMT&quot;&gt;cookie设定，如果网页过期，存盘的cookie将被删除。需要注意的也是必须使用GMT时间格式；6、&lt;meta http-equiv=&quot;Pics-label&quot; contect=&quot;&quot;&gt;网页等级评定，在IE的internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过meta属性来设置的；7、&lt;meta http-equiv=&quot;windows-Target&quot; contect=&quot;_top&quot;&gt;强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用；8、&lt;meta http-equiv=&quot;Page-Enter&quot; contect=&quot;revealTrans(duration=10,transtion= 50)&quot;&gt;和&lt;meta http-equiv=&quot;Page-Exit&quot; contect=&quot;revealTrans(duration=20，transtion=6)&quot;&gt;设定进入和离开页面时的特殊效果，这个功能即FrontPage中的“格式/网页过渡”，不过所加的页面不能够是一个frame页面。Open Graph ProtocolMeta Property=og标签是什么呢?og是一种新的HTTP头部标记，即Open Graph Protocol：The Open Graph Protocol enables any web page to become a rich object in a social graph.+ n3 &#125;即这种协议可以让网页成为一个“富媒体对象”。用了Meta Property=og标签，就是你同意了网页内容可以被其他社会化网站引用等，目前这种协议被SNS网站如Fackbook、renren采用。SNS已经成为网络上的一大热门应用，优质的内容通过分享在好友间迅速传播。为了提高站外内容的传播效率，2010年F8会议上Facebook公布 了一套开放内容协议(Open Graph Protocol)，任何网页只要遵守该协议，SNS就能从页面上提取最有效的信息并呈现给用户。 &lt;meta property=”og:type” content=”video”/&gt; &lt;meta property=”og:title” content=”五月天_突然好想你MV现场版”/&gt; &lt;meta property=”og:image” content=”http://g1.ykimg.com/0100641F464A ... 9-76EA-E5E20A1887C4″/&gt; &lt;meta property=”og:url” content=”http://v.youku.com/v_show/id_XMTIyMTY5NzMy.html”/&gt; &lt;meta property=”og:videosrc” content=”http://player.youku.com/player.p ... AutoPlay=true/v.swf”/&gt; &lt;meta property=”og:width” content=”500″ /&gt; &lt;meta property=”og:height” content=”416″ /&gt; &lt;meta property=”og:type” content=”video”/&gt; &lt;meta property=”og:title” content=”五月天_突然好想你MV现场版_AA”/&gt; &lt;meta property=”og:image” content=”http://g1.ykimg.com/0100641F464A ... EA-E5E20A1887C44444″/&gt; &lt;meta property=”og:url” content=”http://v.youku.com/v_show/id_XMTIyMTY5NzMyyyyyyyyyyyyyyyy.html”/&gt; &lt;meta property=”og:videosrc” content=”http://player.youku.com/player.p ... AutoPlay=true/y.swf”/&gt; &lt;meta property=”og:width” content=”600″ /&gt; &lt;meta property=”og:height” content=”716″/&gt; &lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-CN&quot; /&gt; html代码语言采用中文 &lt;meta property=&quot;qc:admins&quot; content=&quot;153033120760567656375&quot; /&gt; QQ登陆声明 &lt;meta property=&quot;wb:webmaster&quot; content=&quot;e9da5e10879ed7c9&quot; /&gt; 微博登陆声明 &lt;meta name=&quot;google-site-verification&quot; content=&quot;tPkY-Quj85Ni78uIWOIREPO9k5xczDgjch10qsLfVfs&quot; /&gt; google的网站认证代码，证明该网站的所有者是你","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"防止页面被iframe嵌套","date":"2017-06-06T02:40:42.000Z","path":"2017/06/06/防止网页被iframe嵌套/","text":"自己的网页被别人盗用很不爽吧，以下是几种解方案 方案一if (top != self) { top.location = self.location; } 方案二if (self == top) { var theBody = document.getElementsByTagName(&apos;body&apos;)[0]; theBody.style.display = &quot;block&quot;; } else { top.location = self.location; } 方案三在响应头里加一个X-Frame-Options 取值有三种，大部分浏览器都支持： 1. DENY：浏览器拒绝当前页面加载任何Frame页面 2. SAMEORIGIN：frame页面的地址只能为同源域名下的页面 3. ALLOW-FROM origin：origin为允许frame加载的页面地址","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"省略号动画","date":"2017-06-05T02:40:42.000Z","path":"2017/06/05/省略号动画/","text":"一些漂亮的等待动画：点这里 三个点的简单等待的动画效果： .dotting{ display: inline-block; width: 20px; min-height: 4px; padding-right: 4px; border-left: 4px solid currentColor; border-right: 4px solid currentColor; background-color: currentColor; background-clip: content-box; box-sizing: border-box; -webkit-animation: dot 4s infinite step-start both; animation: dot 4s infinite step-start both; &amp;:before{ content: &apos;...&apos;; /* IE8 */ } &amp;::before{ content: &apos;&apos;; } } :root .dotting { margin-left: 4px; padding-left: 4px; } /* IE9+ */ @-webkit-keyframes dot { 25% { border-color: transparent; background-color: transparent; } 50% { border-right-color: transparent; background-color: transparent; } 75% { border-right-color: transparent; } } @keyframes dot { 25% { border-color: transparent; background-color: transparent; } 50% { border-right-color: transparent; background-color: transparent; } 75% { border-right-color: transparent; } }","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"placeholder支持","date":"2017-06-01T00:16:16.000Z","path":"2017/06/01/placeholder的支持/","text":"IE9及以上不支持placeholder属性，可以通过一下方法模拟： if(&apos;placeholder&apos; in document.createElement(&apos;input&apos;)){ }else{ $(&apos;[placeholder]&apos;).focus(function() { var input = $(this); if (input.val() == input.attr(&apos;placeholder&apos;)) { input.val(&apos;&apos;); input.removeClass(&apos;placeholder&apos;); } }).blur(function() { var input = $(this); if (input.val() == &apos;&apos; || input.val() == input.attr(&apos;placeholder&apos;)) { input.addClass(&apos;placeholder&apos;); input.val(input.attr(&apos;placeholder&apos;)); } }).blur(); }","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"移动端touch事件整理","date":"2017-05-28T06:44:44.000Z","path":"2017/05/28/移动端touch事件/","text":"移动端触摸事件 touchstart事件：触摸时触发（坐标信息可以从touches里获得） touchmove事件：滑动时触发（同上） touched事件：手指离开时触发（需要从changeTouches中获取离开时坐标） touchcancel事件：当系统停止跟踪触摸的时候触发 上面的这些事件都会冒泡，也都可以取消。虽然这些触摸事件没有在DOM规范中定义，但是它们却是以兼容DOM的方式实现的。所以，每个触摸事件的event对象都提供了在鼠标实践中常见的属性：bubbles(起泡事件的类型)、cancelable(是否用 preventDefault() 方法可以取消与事件关联的默认动作)、clientX(返回当事件被触发时，鼠标指针的水平坐标)、clientY(返回当事件触发时，鼠标指针的垂直坐标)、screenX(当某个事件被触发时，鼠标指针的水平坐标)和screenY(返回当某个事件被触发时，鼠标指针的垂直坐标)。除了常见的DOM属性，触摸事件还包含下面三个用于跟踪触摸的属性。 touches：表示当前跟踪的触摸操作的touch对象的数组。 targetTouches：特定于事件目标的Touch对象的数组。 changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。 每个Touch对象包含的属性如下。 clientX：触摸目标在视口中的x坐标。 clientY：触摸目标在视口中的y坐标。 identifier：标识触摸的唯一ID。 pageX：触摸目标在页面中的x坐标。 pageY：触摸目标在页面中的y坐标。 screenX：触摸目标在屏幕中的x坐标。 screenY：触摸目标在屏幕中的y坐标。 target：触目的DOM节点目标。","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"图片预览上传","date":"2017-05-27T08:36:36.000Z","path":"2017/05/27/图片预览上传/","text":"图片的上传和预览 HTML的布局&lt;div class=&apos;uploadImgBox&apos;&gt; &lt;ul class=&apos;imgList&apos; id=&quot;imgListModify&quot;&gt; &lt;li style=&apos;background-image:url(img/2.jpg)&apos;&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/li&gt; &lt;li style=&apos;background-image:url(img/1.jpg)&apos;&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;a class=&apos;button button-big&apos; onclick=&quot;loadImg(this)&quot;&gt;上传图片&lt;/a&gt; &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; multiple id=&quot;abc&quot;&gt; &lt;/div&gt; SCSS样式.uploadImgBox{ padding: 0 .75rem; .imgList { display: flex; padding-left: 0; margin-bottom: .5rem; flex-flow: row wrap; li{ text-align: center; width: 100px; height: 100px; background-repeat: no-repeat; background-position: center center; background-size: cover; margin: .5rem .5rem .5rem 0; position: relative; span{ width: 20px; height: 20px; line-height: 20px; font-size: 1.2em; background: #000; border-radius: 50%; color:#fff; position: absolute; right: 0; top: 0; margin: -10px -10px 0 0; } } } input { display: none; } } js代码function loadImg(that) { if (typeof FileReader === &apos;undefined&apos;) { $.toast(&apos;您的手机不支持上传图片&apos;, 2000,&apos;toast-11&apos;); return } var inp = $(that).next(&apos;input&apos;)[0] inp.click() inp.onchange=function() { var imgFile = inp.files if (imgFile.length == 0) return if (imgFile.length &gt; 9){ $.toast(&apos;最多上传9张图片&apos;) } $(imgFile).each(function (i, v) { if (!/\\/(?:jpeg|png|gif)/i.test(v.type)) return; var reader = new FileReader() reader.readAsDataURL(v); reader.onload = function () { var url = this.result $(that).prev(&apos;ul&apos;).append(&quot;&lt;li style=&apos;background-image:url(&quot;+url+&quot;)&apos;&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/li&gt;&quot;) } }) } } 参考代码 （压缩 预览 上传）原网址找不到了：js部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228function uploadImg() &#123; var filechooser = document.getElementById(\"chooseImg\"); // 用于压缩图片的canvas var canvas = document.createElement(\"canvas\"); var ctx = canvas.getContext('2d'); // 瓦片canvas var tCanvas = document.createElement(\"canvas\"); var tctx = tCanvas.getContext(\"2d\"); var maxsize = 100 * 1024; $(\"#upload\").on(\"click\", function () &#123; filechooser.click(); &#125;) filechooser.onchange = function () &#123; if (!this.files.length) return; var files = Array.prototype.slice.call(this.files); if (files.length &gt; 9) &#123; alert(\"最多同时只可上传9张图片\"); return; &#125; files.forEach(function (file, i) &#123; if (!/\\/(?:jpeg|png|gif)/i.test(file.type)) return; var reader = new FileReader(); var li = document.createElement(\"li\"); // 获取图片大小 var size = file.size / 1024 &gt; 1024 ? (~~(10 * file.size / 1024 / 1024)) / 10 + \"MB\" : ~~(file.size / 1024) + \"KB\"; li.innerHTML = '&lt;div class=\"progress\"&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=\"size\"&gt;' + size + '&lt;/div&gt;'; $(\".img-list\").append($(li)); reader.onload = function () &#123; var result = this.result; var img = new Image(); img.src = result; $(li).css(\"background-image\", \"url(\" + result + \")\"); //如果图片大小小于100kb，则直接上传 if (result.length &lt;= maxsize) &#123; img = null; upload(result, file.type, $(li)); return; &#125; // 图片加载完毕之后进行压缩，然后上传 if (img.complete) &#123; callback(); &#125; else &#123; img.onload = callback; &#125; function callback() &#123; var data = compress(img); upload(data, file.type, $(li)); img = null; &#125; &#125;; reader.readAsDataURL(file); &#125;) &#125;; // 使用canvas对大图片进行压缩 function compress(img) &#123; var initSize = img.src.length; var width = img.width; var height = img.height; //如果图片大于四百万像素，计算压缩比并将大小压至400万以下 var ratio; if ((ratio = width * height / 4000000) &gt; 1) &#123; ratio = Math.sqrt(ratio); width /= ratio; height /= ratio; &#125; else &#123; ratio = 1; &#125; canvas.width = width; canvas.height = height; // 铺底色 ctx.fillStyle = \"#fff\"; ctx.fillRect(0, 0, canvas.width, canvas.height); //如果图片像素大于100万则使用瓦片绘制 var count; if ((count = width * height / 1000000) &gt; 1) &#123; count = ~~(Math.sqrt(count) + 1); //计算要分成多少块瓦片 // 计算每块瓦片的宽和高 var nw = ~~(width / count); var nh = ~~(height / count); tCanvas.width = nw; tCanvas.height = nh; for (var i = 0; i &lt; count; i++) &#123; for (var j = 0; j &lt; count; j++) &#123; tctx.drawImage(img, i * nw * ratio, j * nh * ratio, nw * ratio, nh * ratio, 0, 0, nw, nh); ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh); &#125; &#125; &#125; else &#123; ctx.drawImage(img, 0, 0, width, height); &#125; //进行最小压缩 var ndata = canvas.toDataURL('image/jpeg', 0.1); console.log('压缩前：' + initSize); console.log('压缩后：' + ndata.length); console.log('压缩率：' + ~~(100 * (initSize - ndata.length) / initSize) + \"%\"); tCanvas.width = tCanvas.height = canvas.width = canvas.height = 0; return ndata; &#125; // 图片上传，将base64的图片转成二进制对象，塞进formdata上传 function upload(basestr, type, $li) &#123; var text = window.atob(basestr.split(\",\")[1]); var buffer = new Uint8Array(text.length); var pecent = 0, loop = null; for (var i = 0; i &lt; text.length; i++) &#123; buffer[i] = text.charCodeAt(i); &#125; var blob = getBlob([buffer], type); var xhr = new XMLHttpRequest(); var formdata = getFormData(); formdata.append('imagefile', blob); xhr.open('post', '/cupload'); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; var jsonData = JSON.parse(xhr.responseText); var imagedata = jsonData[0] || &#123;&#125;; var text = imagedata.path ? '上传成功' : '上传失败'; console.log(text + '：' + imagedata.path); clearInterval(loop); //当收到该消息时上传完毕 $li.find(\".progress span\").animate(&#123; 'width': \"100%\" &#125;, pecent &lt; 95 ? 200 : 0, function () &#123; $(this).html(text); &#125;); if (!imagedata.path) return; $(\".pic-list\").append('&lt;a href=\"' + imagedata.path + '\"&gt;' + imagedata.name + '（' + imagedata.size + '）&lt;img src=\"' + imagedata.path + '\" /&gt;&lt;/a&gt;'); &#125; &#125;; //数据发送进度，前50%展示该进度 xhr.upload.addEventListener('progress', function (e) &#123; if (loop) return; pecent = ~~(100 * e.loaded / e.total) / 2; $li.find(\".progress span\").css('width', pecent + \"%\"); if (pecent == 50) &#123; mockProgress(); &#125; &#125;, false); //数据后50%用模拟进度 function mockProgress() &#123; if (loop) return; loop = setInterval(function () &#123; pecent++; $li.find(\".progress span\").css('width', pecent + \"%\"); if (pecent == 99) &#123; clearInterval(loop); &#125; &#125;, 100) &#125; xhr.send(formdata); &#125; /** * 获取blob对象的兼容性写法 * @param buffer * @param format * @returns &#123;*&#125; */ function getBlob(buffer, format) &#123; try &#123; return new Blob(buffer, &#123; type: format &#125;); &#125; catch (e) &#123; var bb = new(window.BlobBuilder || window.WebKitBlobBuilder || window.MSBlobBuilder); buffer.forEach(function (buf) &#123; bb.append(buf); &#125;); return bb.getBlob(format); &#125; &#125; /** * 获取formdata */ function getFormData() &#123; var isNeedShim = ~navigator.userAgent.indexOf('Android') &amp;&amp; ~navigator.vendor.indexOf('Google') &amp;&amp; !~navigator.userAgent.indexOf('Chrome') &amp;&amp; navigator.userAgent.match(/AppleWebKit\\/(\\d+)/).pop() &lt;= 534; return isNeedShim ? new FormDataShim() : new FormData() &#125; /** * formdata 补丁, 给不支持formdata上传blob的android机打补丁 * @constructor */ function FormDataShim() &#123; console.warn('using formdata shim'); var o = this, parts = [], boundary = Array(21).join('-') + (+new Date() * (1e16 * Math.random())).toString(36), oldSend = XMLHttpRequest.prototype.send; this.append = function (name, value, filename) &#123; parts.push('--' + boundary + '\\r\\nContent-Disposition: form-data; name=\"' + name + '\"'); if (value instanceof Blob) &#123; parts.push('; filename=\"' + (filename || 'blob') + '\"\\r\\nContent-Type: ' + value.type + '\\r\\n\\r\\n'); parts.push(value); &#125; else &#123; parts.push('\\r\\n\\r\\n' + value); &#125; parts.push('\\r\\n'); &#125;; // Override XHR send() XMLHttpRequest.prototype.send = function (val) &#123; var fr, data, oXHR = this; if (val === o) &#123; // Append the final boundary string parts.push('--' + boundary + '--\\r\\n'); // Create the blob data = getBlob(parts); // Set up and read the blob into an array to be sent fr = new FileReader(); fr.onload = function () &#123; oldSend.call(oXHR, fr.result); &#125;; fr.onerror = function (err) &#123; throw err; &#125;; fr.readAsArrayBuffer(data); // Set the multipart content type and boudary this.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + boundary); XMLHttpRequest.prototype.send = oldSend; &#125; else &#123; oldSend.call(this, val); &#125; &#125;; &#125;&#125;","tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"markdown语法教程","date":"2017-05-25T09:43:03.000Z","path":"2017/05/25/markdown语法教程/","text":"完整版Markdown 语法手册（完整版） 目录[TOC] 目录如上[TOC]所示 斜体和粗体我是斜体 或 斜体 *斜体* _斜体_ 我是粗体 **粗体** 删除线 ~~删除线~~ 链接点我 ​ [点我]（https://saihy2016.github.io/） ![图片]（C:\\Users\\Administrator\\Desktop\\my\\blogMD\\hua.jpg “美丽花儿”） 锚点 我要调到 列表引用插入图像内容目录注脚LaTeX公式流程图表格","tags":[]},{"title":"hexo博客搭好啦","date":"2017-05-20T01:40:24.000Z","path":"2017/05/20/hexo博客搭好啦/","text":"折腾了一上午，终于搭好了自己的博客啦，好开心，好兴奋，今天520，我要去陪女票啦，美好的一天，嗯木啊","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Hello World","date":"2017-05-18T02:26:26.000Z","path":"2017/05/18/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]